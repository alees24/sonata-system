// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Package auto-generated by `reggen` containing data structure

package dma_reg_pkg;

  // Address widths within the block
  parameter int BlockAw = 7;

  ////////////////////////////
  // Typedefs for registers //
  ////////////////////////////

  typedef struct packed {
    struct packed {
      logic        q;
    } error;
    struct packed {
      logic        q;
    } completed;
  } dma_reg2hw_intr_state_reg_t;

  typedef struct packed {
    struct packed {
      logic        q;
    } error;
    struct packed {
      logic        q;
    } completed;
  } dma_reg2hw_intr_enable_reg_t;

  typedef struct packed {
    struct packed {
      logic        q;
      logic        qe;
    } error;
    struct packed {
      logic        q;
      logic        qe;
    } completed;
  } dma_reg2hw_intr_test_reg_t;

  typedef struct packed {
    struct packed {
      logic        q;
      logic        qe;
    } abort;
    struct packed {
      logic        q;
      logic        qe;
    } pause;
    struct packed {
      logic        q;
      logic        qe;
    } start;
  } dma_reg2hw_control_reg_t;

  typedef struct packed {
    struct packed {
      logic [1:0]  q;
    } col_inc;
    struct packed {
      logic        q;
    } enable;
  } dma_reg2hw_src_config_reg_t;

  typedef struct packed {
    logic [31:0] q;
  } dma_reg2hw_src_cap_lo_reg_t;

  typedef struct packed {
    logic [31:0] q;
  } dma_reg2hw_src_cap_hi_reg_t;

  typedef struct packed {
    logic [31:0] q;
  } dma_reg2hw_src_stride_reg_t;

  typedef struct packed {
    logic [19:0] q;
  } dma_reg2hw_src_row_len_reg_t;

  typedef struct packed {
    logic [15:0] q;
  } dma_reg2hw_src_rows_reg_t;

  typedef struct packed {
    struct packed {
      logic [1:0]  q;
    } col_inc;
    struct packed {
      logic        q;
    } enable;
  } dma_reg2hw_dst_config_reg_t;

  typedef struct packed {
    logic [31:0] q;
  } dma_reg2hw_dst_cap_lo_reg_t;

  typedef struct packed {
    logic [31:0] q;
  } dma_reg2hw_dst_cap_hi_reg_t;

  typedef struct packed {
    logic [31:0] q;
  } dma_reg2hw_dst_stride_reg_t;

  typedef struct packed {
    logic [19:0] q;
  } dma_reg2hw_dst_row_len_reg_t;

  typedef struct packed {
    logic [15:0] q;
  } dma_reg2hw_dst_rows_reg_t;

  typedef struct packed {
    struct packed {
      logic        d;
      logic        de;
    } completed;
    struct packed {
      logic        d;
      logic        de;
    } error;
  } dma_hw2reg_intr_state_reg_t;

  typedef struct packed {
    struct packed {
      logic [3:0]  d;
    } state;
    struct packed {
      logic        d;
    } rd_idle;
    struct packed {
      logic        d;
    } wr_idle;
    struct packed {
      logic        d;
    } rd_active;
    struct packed {
      logic        d;
    } wr_active;
    struct packed {
      logic        d;
    } rd_paused;
    struct packed {
      logic        d;
    } wr_paused;
    struct packed {
      logic        d;
    } wr_error;
    struct packed {
      logic        d;
    } rd_error;
    struct packed {
      logic [7:0]  d;
    } committed;
    struct packed {
      logic [7:0]  d;
    } wr_pending;
  } dma_hw2reg_status_reg_t;

  typedef struct packed {
    struct packed {
      logic        d;
      logic        de;
    } rd_cap_error;
    struct packed {
      logic        d;
      logic        de;
    } wr_cap_error;
    struct packed {
      logic        d;
      logic        de;
    } rd_bus_error;
    struct packed {
      logic        d;
      logic        de;
    } wr_bus_error;
  } dma_hw2reg_error_reg_t;

  typedef struct packed {
    logic [7:0]  d;
    logic        de;
  } dma_hw2reg_src_status_reg_t;

  typedef struct packed {
    logic [31:0] d;
    logic        de;
  } dma_hw2reg_src_cap_lo_reg_t;

  typedef struct packed {
    logic [31:0] d;
    logic        de;
  } dma_hw2reg_src_cap_hi_reg_t;

  typedef struct packed {
    logic [19:0] d;
    logic        de;
  } dma_hw2reg_src_row_len_reg_t;

  typedef struct packed {
    logic [15:0] d;
    logic        de;
  } dma_hw2reg_src_rows_reg_t;

  typedef struct packed {
    logic [7:0]  d;
    logic        de;
  } dma_hw2reg_dst_status_reg_t;

  typedef struct packed {
    logic [31:0] d;
    logic        de;
  } dma_hw2reg_dst_cap_lo_reg_t;

  typedef struct packed {
    logic [31:0] d;
    logic        de;
  } dma_hw2reg_dst_cap_hi_reg_t;

  typedef struct packed {
    logic [19:0] d;
    logic        de;
  } dma_hw2reg_dst_row_len_reg_t;

  typedef struct packed {
    logic [15:0] d;
    logic        de;
  } dma_hw2reg_dst_rows_reg_t;

  // Register -> HW type
  typedef struct packed {
    dma_reg2hw_intr_state_reg_t intr_state; // [283:282]
    dma_reg2hw_intr_enable_reg_t intr_enable; // [281:280]
    dma_reg2hw_intr_test_reg_t intr_test; // [279:276]
    dma_reg2hw_control_reg_t control; // [275:270]
    dma_reg2hw_src_config_reg_t src_config; // [269:267]
    dma_reg2hw_src_cap_lo_reg_t src_cap_lo; // [266:235]
    dma_reg2hw_src_cap_hi_reg_t src_cap_hi; // [234:203]
    dma_reg2hw_src_stride_reg_t src_stride; // [202:171]
    dma_reg2hw_src_row_len_reg_t src_row_len; // [170:151]
    dma_reg2hw_src_rows_reg_t src_rows; // [150:135]
    dma_reg2hw_dst_config_reg_t dst_config; // [134:132]
    dma_reg2hw_dst_cap_lo_reg_t dst_cap_lo; // [131:100]
    dma_reg2hw_dst_cap_hi_reg_t dst_cap_hi; // [99:68]
    dma_reg2hw_dst_stride_reg_t dst_stride; // [67:36]
    dma_reg2hw_dst_row_len_reg_t dst_row_len; // [35:16]
    dma_reg2hw_dst_rows_reg_t dst_rows; // [15:0]
  } dma_reg2hw_t;

  // HW -> register type
  typedef struct packed {
    dma_hw2reg_intr_state_reg_t intr_state; // [265:262]
    dma_hw2reg_status_reg_t status; // [261:234]
    dma_hw2reg_error_reg_t error; // [233:226]
    dma_hw2reg_src_status_reg_t src_status; // [225:217]
    dma_hw2reg_src_cap_lo_reg_t src_cap_lo; // [216:184]
    dma_hw2reg_src_cap_hi_reg_t src_cap_hi; // [183:151]
    dma_hw2reg_src_row_len_reg_t src_row_len; // [150:130]
    dma_hw2reg_src_rows_reg_t src_rows; // [129:113]
    dma_hw2reg_dst_status_reg_t dst_status; // [112:104]
    dma_hw2reg_dst_cap_lo_reg_t dst_cap_lo; // [103:71]
    dma_hw2reg_dst_cap_hi_reg_t dst_cap_hi; // [70:38]
    dma_hw2reg_dst_row_len_reg_t dst_row_len; // [37:17]
    dma_hw2reg_dst_rows_reg_t dst_rows; // [16:0]
  } dma_hw2reg_t;

  // Register offsets
  parameter logic [BlockAw-1:0] DMA_INTR_STATE_OFFSET = 7'h 0;
  parameter logic [BlockAw-1:0] DMA_INTR_ENABLE_OFFSET = 7'h 4;
  parameter logic [BlockAw-1:0] DMA_INTR_TEST_OFFSET = 7'h 8;
  parameter logic [BlockAw-1:0] DMA_CONTROL_OFFSET = 7'h c;
  parameter logic [BlockAw-1:0] DMA_STATUS_OFFSET = 7'h 10;
  parameter logic [BlockAw-1:0] DMA_ERROR_OFFSET = 7'h 14;
  parameter logic [BlockAw-1:0] DMA_SRC_CONFIG_OFFSET = 7'h 20;
  parameter logic [BlockAw-1:0] DMA_SRC_STATUS_OFFSET = 7'h 24;
  parameter logic [BlockAw-1:0] DMA_SRC_CAP_LO_OFFSET = 7'h 28;
  parameter logic [BlockAw-1:0] DMA_SRC_CAP_HI_OFFSET = 7'h 2c;
  parameter logic [BlockAw-1:0] DMA_SRC_STRIDE_OFFSET = 7'h 30;
  parameter logic [BlockAw-1:0] DMA_SRC_ROW_LEN_OFFSET = 7'h 34;
  parameter logic [BlockAw-1:0] DMA_SRC_ROWS_OFFSET = 7'h 38;
  parameter logic [BlockAw-1:0] DMA_DST_CONFIG_OFFSET = 7'h 40;
  parameter logic [BlockAw-1:0] DMA_DST_STATUS_OFFSET = 7'h 44;
  parameter logic [BlockAw-1:0] DMA_DST_CAP_LO_OFFSET = 7'h 48;
  parameter logic [BlockAw-1:0] DMA_DST_CAP_HI_OFFSET = 7'h 4c;
  parameter logic [BlockAw-1:0] DMA_DST_STRIDE_OFFSET = 7'h 50;
  parameter logic [BlockAw-1:0] DMA_DST_ROW_LEN_OFFSET = 7'h 54;
  parameter logic [BlockAw-1:0] DMA_DST_ROWS_OFFSET = 7'h 58;

  // Reset values for hwext registers and their fields
  parameter logic [1:0] DMA_INTR_TEST_RESVAL = 2'h 0;
  parameter logic [0:0] DMA_INTR_TEST_COMPLETED_RESVAL = 1'h 0;
  parameter logic [0:0] DMA_INTR_TEST_ERROR_RESVAL = 1'h 0;
  parameter logic [31:0] DMA_STATUS_RESVAL = 32'h 0;

  // Register index
  typedef enum int {
    DMA_INTR_STATE,
    DMA_INTR_ENABLE,
    DMA_INTR_TEST,
    DMA_CONTROL,
    DMA_STATUS,
    DMA_ERROR,
    DMA_SRC_CONFIG,
    DMA_SRC_STATUS,
    DMA_SRC_CAP_LO,
    DMA_SRC_CAP_HI,
    DMA_SRC_STRIDE,
    DMA_SRC_ROW_LEN,
    DMA_SRC_ROWS,
    DMA_DST_CONFIG,
    DMA_DST_STATUS,
    DMA_DST_CAP_LO,
    DMA_DST_CAP_HI,
    DMA_DST_STRIDE,
    DMA_DST_ROW_LEN,
    DMA_DST_ROWS
  } dma_id_e;

  // Register width information to check illegal writes
  parameter logic [3:0] DMA_PERMIT [20] = '{
    4'b 0001, // index[ 0] DMA_INTR_STATE
    4'b 0001, // index[ 1] DMA_INTR_ENABLE
    4'b 0001, // index[ 2] DMA_INTR_TEST
    4'b 0001, // index[ 3] DMA_CONTROL
    4'b 1111, // index[ 4] DMA_STATUS
    4'b 0001, // index[ 5] DMA_ERROR
    4'b 0001, // index[ 6] DMA_SRC_CONFIG
    4'b 1111, // index[ 7] DMA_SRC_STATUS
    4'b 1111, // index[ 8] DMA_SRC_CAP_LO
    4'b 1111, // index[ 9] DMA_SRC_CAP_HI
    4'b 1111, // index[10] DMA_SRC_STRIDE
    4'b 0111, // index[11] DMA_SRC_ROW_LEN
    4'b 0011, // index[12] DMA_SRC_ROWS
    4'b 0001, // index[13] DMA_DST_CONFIG
    4'b 1111, // index[14] DMA_DST_STATUS
    4'b 1111, // index[15] DMA_DST_CAP_LO
    4'b 1111, // index[16] DMA_DST_CAP_HI
    4'b 1111, // index[17] DMA_DST_STRIDE
    4'b 0111, // index[18] DMA_DST_ROW_LEN
    4'b 0011  // index[19] DMA_DST_ROWS
  };

endpackage
